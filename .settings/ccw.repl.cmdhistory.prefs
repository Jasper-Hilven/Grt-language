cmdhistory=["(run-tests)" "(add-line \\"1c\\" 0)" "(run-tests)" "(parse-by-parentheses(lex-it \\"3.24\\") 0)" "(lex-it \\"3.24\\")" " (parse-by-parentheses(lex-it [\\"3.24\\"]) 0)" "(build-identifier-navigation 0 (parse-by-parentheses(lex-it \\"3.24\\") 0))" "(build-identifier-navigation 0 (parse-by-parentheses(lex-it [\\"3.24\\"]) 0))" "\\n(build-identifier-navigation 0 (parse-by-parentheses(lex-it [\\"3.24 \\"]) 0))" "(build-identifier-navigation 0 (parse-by-parentheses(lex-it [\\"3.24 3\\"]) 0))" "(parse-by-parentheses(lex-it [\\"3.24 3\\"]) 0)" "(lex-it [\\"3.24 3\\"])" " (parse-by-parentheses (lex-it [\\"3.24 3\\"]) 0)" "(parse-by-parentheses (lex-it [\\"3.24 3 3\\"]) 0)" "(parse-by-parentheses (lex-it [\\"3\\"]) 0)" "(parse-by-parentheses (lex-it [\\"323\\"]) 0)" "(parse-by-parentheses (lex-it [\\"323 \\"]) 0)" "(parse-by-parentheses (lex-it [\\"32 3\\"]) 0)" "(parse-by-parentheses (lex-it [\\"(323 2 3)\\"]) 0)" "(parse-by-parentheses (lex-it [\\"(323 2)\\"]) 0)" "(build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(323 2 3)\\"]) 0))" "(build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"()\\"]) -1))" "(build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(323 2 3)\\"]) 0))" "(build-identifier-navigation 0 (parse-by-parentheses (lex-it \\"(3.15 3.16)\\") 0) )" "(build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) )" "(pprint (build-identifier-navigation 0 (parse-by-parentheses (lex-it \\"(3.15 3.16)\\") 0) ))" "\\n(clojure.pprint (build-identifier-navigation 0 (parse-by-parentheses (lex-it \\"(3.15 3.16)\\") 0) ))" "(set clojure.pprint\\\\print-pretty true)" "(require clojure.pprint)" "(use 'clojure.pprint)" "(clojure.pprint (build-identifier-navigation 0 (parse-by-parentheses (lex-it \\"(3.15 3.16)\\") 0) ))" "(pprint (build-identifier-navigation 0 (parse-by-parentheses (lex-it \\"(3.15 3.16)\\") 0) ))" "(pprint (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) ))" "(pprint (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"3.16\\"]) 0) ))" "(pprint (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(())\\"]) 0) ))" "(pprint (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) ))" "(pprint (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) )" "(pprint (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) ))" "(defn build-identifier-navigation2 [current-count remainder]\\r\\n  (if (\:is-leaf remainder)\\r\\n    {\:next-count (inc current-count) \:annotated (assoc remainder \:id current-count)}\\r\\n    (let [[new-count updated-mid]\\r\\n          (loop [sub-current-count (inc current-count) remaining (\:mid remainder) acc []]\\r\\n            (if (empty? remaining)\\r\\n              [sub-current-count acc]\\r\\n              (let [sub-nav (build-identifier-navigation sub-current-count (first remaining))\\r\\n                    updated-count (\:next-count sub-nav)\\r\\n                    printed-sub (pr \\"subnav\: \\" sub-nav \\"first remaining\\" (first remaining))\\r\\n                    updated-sub-nav (assoc (\:annotated  sub-nav) \:id updated-count)]\\r\\n                (recur updated-count (rest remaining) (into acc [updated-sub-nav])))))]\\r\\n      {\:next-count new-count \:annotated (assoc remainder \:mid updated-mid \:id current-count)})))" "(defn build-identifier-navigation [current-count remainder]\\r\\n  (if (\:is-leaf remainder)\\r\\n    (7/0)\\r\\n    (let [[new-count updated-mid]\\r\\n          (loop [sub-current-count (inc current-count) remaining (\:mid remainder) acc []]\\r\\n            (if (empty? remaining)\\r\\n              [sub-current-count acc]\\r\\n              (let [sub-nav (build-identifier-navigation sub-current-count (first remaining))\\r\\n                    updated-count (\:next-count sub-nav)\\r\\n                    printed-sub (pr \\"subnav\: \\" sub-nav \\"first remaining\\" (first remaining))\\r\\n                    updated-sub-nav (assoc (\:annotated  sub-nav) \:id updated-count)]\\r\\n                (recur updated-count (rest remaining) (into acc [updated-sub-nav])))))]\\r\\n      {\:next-count new-count \:annotated (assoc remainder \:mid updated-mid \:id current-count)})))" "(defn build-identifier-navigation2 [current-count remainder]\\r\\n  (if (\:is-leaf remainder)\\r\\n    \\"RECEIVED IT\\"\\r\\n    (let [[new-count updated-mid]\\r\\n          (loop [sub-current-count (inc current-count) remaining (\:mid remainder) acc []]\\r\\n            (if (empty? remaining)\\r\\n              [sub-current-count acc]\\r\\n              (let [sub-nav (build-identifier-navigation sub-current-count (first remaining))\\r\\n                    updated-count (\:next-count sub-nav)\\r\\n                    printed-sub (pr \\"subnav\: \\" sub-nav \\"first remaining\\" (first remaining))\\r\\n                    updated-sub-nav (assoc (\:annotated  sub-nav) \:id updated-count)]\\r\\n                (recur updated-count (rest remaining) (into acc [updated-sub-nav])))))]\\r\\n      {\:next-count new-count \:annotated (assoc remainder \:mid updated-mid \:id current-count)})))" " (pprint (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) ))" " (pprint (build-identifier-navigation2 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) ))" " (pprint (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) ))" "(parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0)" "(assoc (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) \:b \\"b\\")" "(parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0)" "(pprint (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) ))" "(pprint (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) )" "(pprint (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) ))" "(pprint (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"((3.15 3.16))\\"]) 0) ))" "(pprint (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16 telefoon)\\"]) 0) ))" "(pprint (remove-spaces (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) )))" " (pprint (remove-spaces (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) )))" " (pprint ((filter \#(not\= (\:type %) \:space) (\:mid remainder) (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) ))))" "(pprint ((filter \#(not\= (\:type %) \:space) (\:mid  (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) )))))" "(pprint (remove-spaces (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) )))" "(\:is-leaf (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) ))" "(pprint (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) ))" "(pprint (\:is-leaf (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) )))" "(pprint (get \:is-leaf (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) )))" "(let [remainder (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) )] (assoc remainder \:mid (filter \#(not(\= (\:type %) \:space)) (\:mid remainder) )))" "(pprint (let [remainder (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) )] (assoc remainder \:mid (filter \#(not(\= (\:type %) \:space)) (\:mid remainder) ))))" "(let [remainder (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) )] (assoc remainder \:mid (filter \#(not(\= (\:type %) \:space)) (\:mid remainder) )))" "(filter \#(false) [1 2 3 4])" "(filter \#((\= false true)) [1 2 3 4])" "(filter \#((\= % true)) [1 2 3 4] )" "(filter \#(% ) [1 2 3 4] )" "(filter \#(eval % ) [1 2 3 4] )" "(filter \#(eval false ) [1 2 3 4] )" "(filter \#((and false (eval % ))) [1 2 3 4] )" "(filter (fn [x]\\r\\n  (\= (count x) 1))" "(filter (fn [x]\\r\\n  (\= (count x) 1)))" "(filter \#(\= (count %) 1)\\r\\n  [\\"a\\" \\"aa\\" \\"b\\" \\"n\\" \\"f\\" \\"lisp\\" \\"clojure\\" \\"q\\" \\"\\"])" "(pprint ((filter \#(not\= (\:type %) \:space) (\:mid remainder) (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) ))))" "> (pprint (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) ))" "> (pprint (remove-spaces (build-identifier-navigation 0 (parse-by-parentheses (lex-it [\\"(3.15 3.16)\\"]) 0) )))" "(\:mid ided)" "(get \:mid ided)" "(ided \:mid)" "ided" "(ided \:next-count)" "(pprint ided)" "(remove-spaces {})" "({} \:is-leaf)" " (if ({} \:is-leaf)  \\"sisi\\" \\"nope\\")" "ided" "(remove-spaces ided)" "(assoc {} \:mid 3 )" "ided" "(remove-spaces ided)" "(pprint (remove-spaces ided))" "(use 'clojure.pprint)" "\=> (remove-spaces ided)" "\\n(remove-spaces ided)" "(pprint (remove-spaces ided))" "(lex-it [\\"3.143\\"])" "(lex-it [\\"3.143 4\\"])" "(lex-it [\\"(3.143)\\"])" "\\n(parse-it (lex-it [\\"(3.143)\\"]))" "(pprint (parse-it (lex-it [\\"(3.143)\\"])))" "\\n(parse-it (lex-it [\\"(() (hallo) (do iets met het getal 3.143)\\"]))" "(pprint (parse-it (lex-it [\\"(() (hallo) (do iets met het getal 3.143)\\"])))" "(pprint (parse-it (lex-it [\\"(() (hallo) (do iets met het getal 3.143))\\"])))" "(add-line \\"0\\" 0)" "(add-line \\"(\\" 0)" "(runtests)" "(run-all-tests)" "(clojure.test.runtests)" "(clojure.test/run-tests)" "(clojure.test/run-all-tests 'test-grt.core-test)" "(clojure.test/run-all-tests test-grt.core-test)" "(clojure.test/run-all-tests 'test-grt.core-test)" "(clojure.test/run-tests)" "(parse-it [])" "(grt.parser.core/parse-it [])" "(grt.parser.hierarchybuilder/parse-by-parentheses [])" "(grt.parser.core/parse-it [])" "(grt.parser.hierarchybuilder/parse-by-parentheses [])" "(parse-leaf-values (grt.parser.hierarchybuilder/parse-by-parentheses []))" "(handle-children (grt.parser.hierarchybuilder/parse-by-parentheses []) parse-leaf-values)" "(let [chand (handle-children (grt.parser.hierarchybuilder/parse-by-parentheses []) parse-leaf-values)]\\n  (\= (children-handled \:type) \:error))" "(let [chand (handle-children (grt.parser.hierarchybuilder/parse-by-parentheses []) parse-leaf-values)]\\r\\n     (\= (chand \:type) \:error))" "(let [chand (handle-children (grt.parser.hierarchybuilder/parse-by-parentheses []) parse-leaf-values)]\\r\\n      (chand \:type) )" "(grt.parser.core/parse-it [])" "(run-tests)" "(grt.parser.core/parse-it [])" "(match-elements [])" "parse-emptypar" "test-grt.core-test/parse-emptypar" "(grt.parser.hierarchybuilder/parse-by-parentheses test-grt.core-test/emptyparentheses)" "(grt.parser.hierarchybuilder/build-identifier-navigation (grt.parser.hierarchybuilder/parse-by-parentheses test-grt.core-test/emptyparentheses))" "(parse-leaf-values (grt.parser.hierarchybuilder/build-identifier-navigation (grt.parser.hierarchybuilder/parse-by-parentheses test-grt.core-test/emptyparentheses)))" "(parse-leaf-values (grt.parser.hierarchybuilder/build-identifier-navigation (grt.parser.hierarchybuilder/parse-by-parentheses test-grt.core-test/emptyparentheses))" "\\n(parse-leaf-values (grt.parser.hierarchybuilder/build-identifier-navigation (grt.parser.hierarchybuilder/parse-by-parentheses test-grt.core-test/emptyparentheses)))" "(b)" "(grt.parser.elementmatcher/b)" "(grt.parser.core/parse-it emptyparentheses)" "(use test-grt.core-test)" "(use 'test-grt.core-test)" "(grt.parser.core/parse-it emptyparentheses)" "\\nemptyparentheses" "(grt.parser.core/parse-till-id emptyparentheses)" "(defn parse-it [lexed] \\r\\n  (grt.parser.core/parse-it emptyparentheses)" "(grt.parser.core/parse-till-id emptyparentheses)" "(clojure.pprint (grt.parser.core/parse-till-id emptyparentheses))" "(grt.parser.core/parse-till-id emptyparentheses)" "(grt.parser.core/parse-it emptyparentheses)" "(parse-leaf-values emptyparentheses)" "(parse-leaf-values emptyparenthesesbuilt)" "(use 'test-grt.core-test)" "(parse-leaf-values emptyparenthesesbuilt)" "emptyparenthesesbuilt" "(let [ST emptyparenthesesbuilt\\n      children-handled \\r\\n          (if (ST \:is-leaf) ST\\r\\n            (assoc ST \:mid (to-array \\r\\n                             (for [element (ST \:mid)] \\r\\n                               element))))] children-handled)" "\\n(let [ST emptyparenthesesbuilt\\r\\n      arry (to-array \\r\\n                             (for [element (ST \:mid)] \\r\\n                               element))\\r\\n      children-handled \\r\\n          (if (ST \:is-leaf) ST\\r\\n            (assoc ST \:mid (to-array \\r\\n                             (for [element (ST \:mid)] \\r\\n                               element))))] arry)" "(let [ST emptyparenthesesbuilt\\r\\n      arry (to-array \\r\\n                             (for [element (ST \:mid)] \\r\\n                               element))\\r\\n      children-handled \\r\\n          (if (ST \:is-leaf) ST\\r\\n            (assoc ST \:mid (to-array \\r\\n                             (for [element (ST \:mid)] \\r\\n                               element))))] (ST \:mid))" "(grt.parser.core/parse-it emptyparentheses)" "((grt.parser.core/parse-it emptyparentheses) \:type)" "(intend-function-evaluation? emptyparenthesesbuilt)" "emptyparenthesesbuilt" "intend-function-evaluation?" "(intend-function-evaluation? emptyparenthesesbuilt)" "(grt.parser.core/intend-function-evaluation? emptyparenthesesbuilt)" "(grt.parser.hierarchybuilder/intend-function-evaluation? emptyparenthesesbuilt)" "(grt.parser.elementmatcher/intend-function-evaluation? emptyparenthesesbuilt)" "(\:type (grt.parser.elementmatcher/intend-function-evaluation? emptyparenthesesbuilt))" "(\:type  emptyparenthesesbuilt)" "emptyparenthesesbuilt" "(grt.parser.core/parse-it emptyparenthesesbuilt)" "(grt.parser.elementmatcher/match-elements emptyparenthesesbuilt)" "(intend-function-evaluation? emptyparenthesesbuilt)" "emptyparenthesesbuilt" "(intend-function-evaluation? emptyparenthesesbuilt)" "(intend-function-evaluation? test-grt.core-test/emptyparenthesesbuilt)" "(intend-function-evaluation? emptyparenthesesbuilt)" "(use 'test-grt.core-test)" "(intend-function-evaluation? emptyparenthesesbuilt)" "(grt.parser.elementmatcher/match-elements emptyparenthesesbuilt)" "(intend-function-evaluation? emptyparenthesesbuilt)" "(match-elements emptyparenthesesbuilt)" "(use test-grt.core-test)" "\=> (use 'test-grt.core-test)" "(use 'test-grt.core-test)" "zerofunctionbuilt" "(clojure.pprint zerofunctionbuilt)" "(clojure.pprint/pprint zerofunctionbuilt)" "(match-elements zerofunctionbuilt)" "(use clojure.pprint)" "(use 'clojure.pprint)" "(pprint (match-elements zerofunctionbuilt))" "(intend-function? zerofunctionbuilt)" "(match-elements zerofunctionbuilt)" "(pprint (match-elements zerofunctionbuilt))" "\=> (pprint (match-elements zerofunctionbuilt))" "(intend-function? zerofunctionbuilt)" "(intend-function? (match-elements zerofunctionbuilt))" " (intend-function? (match-elements zerofunctionbuilt))" " ((match-elements zerofunctionbuilt) \:type)" "((match-elements zerofunctionbuilt) \:mid)" "(not-empty ((match-elements zerofunctionbuilt) \:type))" "(not-empty? ((match-elements zerofunctionbuilt) \:type))" "((match-elements zerofunctionbuilt) \:type)" "((match-elements zerofunctionbuilt) \:mid)" "(not-empty ((match-elements zerofunctionbuilt) \:mid))" "(first ((match-elements zerofunctionbuilt) \:mid))" "(intend-function? (match-elements zerofunctionbuilt))" "(first-containing (match-elements zerofunctionbuilt) \:func-eval)" "((match-elements zerofunctionbuilt) \:mid)" "(first ((match-elements zerofunctionbuilt) \:mid))" "(first-containing (match-elements zerofunctionbuilt) \:func-eval)" "(match-elements zerofunctionbuilt)" "(first-containing (match-elements zerofunctionbuilt) \:func-eval)" "((match-elements zerofunctionbuilt) \:type)" "(first-containing (match-elements zerofunctionbuilt) \:func-eval)" "((match-elements zerofunctionbuilt) \:type)" "(grt.parser.core/parse-it letconstruction)" " (grt.parser.core/parse-it test-grt.core-test/letconstruction)" "(grt.parser.core/parse-it test-grt.core-test/letbuilt)" "(grt.parser.core/parse-it test-grt.core-test/letconstruction)" "(grt.parser.elementmatcher/match-elements test-grt.core-test/letbuilt)" "(intend-let? (grt.parser.core/parse-it test-grt.core-test/letbuilt))" "(grt.parser.core/parse-it test-grt.core-test/letconstruction)" "(intend-let? (grt.parser.core/parse-it test-grt.core-test/letconstruction))" "(first-containing (grt.parser.core/parse-it test-grt.core-test/letconstruction) \:func-eval)" "(\:text (\:lex(intend-let? (grt.parser.core/parse-it test-grt.core-test/letconstruction)))" "(\:text (\:lex(intend-let? (grt.parser.core/parse-it test-grt.core-test/letconstruction))))" "(\:text (\:lex (intend-let? (grt.parser.core/parse-it test-grt.core-test/letconstruction))))" "(\:lex(intend-let? (grt.parser.core/parse-it test-grt.core-test/letconstruction)))" "(\:text (\:lex (qualifier (grt.parser.core/parse-it test-grt.core-test/letconstruction))))" "(\:text (\:lex (first-containing (grt.parser.core/parse-it test-grt.core-test/letconstruction))))" "(\:text (\:lex (first-containing (grt.parser.core/parse-it test-grt.core-test/letconstruction) \:func-eval)))" "(\:count (\:mid (first-containing (grt.parser.core/parse-it test-grt.core-test/letconstruction) \:func-eval)))" "(\:count (\:mid (grt.parser.core/parse-it test-grt.core-test/letconstruction)))" "(grt.parser.core/parse-it test-grt.core-test/letconstruction)" "(pprint (\:count (\:mid (grt.parser.core/parse-it test-grt.core-test/letconstruction))))" "(pprint (\:mid (grt.parser.core/parse-it test-grt.core-test/letconstruction)))" "(count (\:mid (grt.parser.core/parse-it test-grt.core-test/letconstruction)))" "(nth (\:mid (grt.parser.core/parse-it test-grt.core-test/letconstruction)) 1)" "(\:type (nth (\:mid (grt.parser.core/parse-it test-grt.core-test/letconstruction)) 1))" "(intend-let? (grt.parser.core/parse-it test-grt.core-test/letconstruction))" "(grt.parser.core/parse-it test-grt.core-test/letconstruction)" "(first-containing (grt.parser.core/parse-it test-grt.core-test/letconstruction) \:func-eval)" "(and (first-containing (grt.parser.core/parse-it test-grt.core-test/letconstruction) \:func-eval))" "(grt.parser.core/parse-it test-grt.core-test/letconstruction)" "(and (first-containing (grt.parser.core/parse-it test-grt.core-test/letconstruction) \:func-eval))" "(grt.parser.core/parse-it test-grt.core-test/letconstruction)" "(and (first-containing (grt.parser.core/parse-it test-grt.core-test/letconstruction) \:func-eval))" "(grt.parser.core/parse-it test-grt.core-test/letconstruction)" " (grt.parser.core/parse-it test-grt.core-test/letconstruction)" "(pprint  (grt.parser.core/parse-it test-grt.core-test/letconstruction))" "(grt.parser.core/parse-it test-grt.core-test/letconstruction)" "(pprint  (grt.parser.core/parse-it test-grt.core-test/letconstruction))" "(pprint  (grt.parser.core/parse-it test-grt.core-test/zerofunctionbuilt))" "(pprint  (grt.parser.core/parse-it test-grt.core-test/functiondef))"]
eclipse.preferences.version=1
